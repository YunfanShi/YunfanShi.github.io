<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jack's Sync | V4.0 Precision Core</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        :root {
            --primary: #2563eb;       
            --primary-active: #1e40af;
            --bg: #0f172a;            
            --surface: #1e293b;       
            --text-main: #f1f5f9;     
            --text-sec: #94a3b8;      
            --border: #334155;        
            --accent: #06b6d4;
            --success: #10b981;
            --warn: #f59e0b;
            --danger: #ef4444;
        }

        body {
            margin: 0; font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text-main);
            height: 100vh; display: flex; flex-direction: column; overflow: hidden; user-select: none;
        }

        /* === HEADER === */
        header {
            background: var(--surface); padding: 0 20px; height: 60px; display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border);
        }
        .brand { font-weight: 800; font-size: 18px; color: var(--text-main); display: flex; gap: 8px; align-items: center; }
        .version-tag { font-size: 10px; background: var(--primary); padding: 2px 6px; border-radius: 4px; color: white; }

        .header-stats { display: flex; gap: 15px; font-family: 'Roboto Mono'; font-size: 11px; color: var(--text-sec); }
        .stat-item { display: flex; align-items: center; gap: 4px; }
        .stat-val { color: var(--accent); font-weight: 700; }

        /* === LAYOUT === */
        .container { flex: 1; display: grid; grid-template-columns: 300px 1fr; overflow: hidden; }
        
        /* SIDEBAR */
        aside { background: #18212f; border-right: 1px solid var(--border); display: flex; flex-direction: column; z-index: 5; }
        .playlist-header { padding: 15px; border-bottom: 1px solid var(--border); background: var(--surface); }
        .input-group { display: flex; gap: 8px; margin-bottom: 8px; }
        .dark-input { 
            background: #0f172a; border: 1px solid var(--border); color: white; padding: 8px; 
            border-radius: 6px; flex: 1; font-family: 'Roboto Mono'; font-size: 12px; outline: none;
        }
        .dark-input:focus { border-color: var(--primary); }
        .btn-sm { padding: 8px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; font-size: 12px; transition: 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-active); }
        .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-sec); }
        .btn-outline:hover { border-color: var(--text-main); color: var(--text-main); }

        .song-list { flex: 1; overflow-y: auto; }
        .song-item { 
            padding: 12px 15px; border-bottom: 1px solid #1e293b; cursor: pointer; display: flex; 
            justify-content: space-between; align-items: center; transition: 0.1s;
        }
        .song-item:hover { background: #1e293b; }
        .song-item.active { background: rgba(37, 99, 235, 0.1); border-left: 3px solid var(--primary); }
        .song-info h4 { margin: 0; font-size: 13px; font-weight: 500; color: var(--text-main); }
        .song-info span { font-size: 10px; color: var(--text-sec); font-family: 'Roboto Mono'; }
        
        /* MAIN AREA */
        main { display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; }
        
        .sync-status { 
            position: absolute; top: 20px; font-family: 'Roboto Mono'; font-size: 12px; 
            padding: 6px 12px; border-radius: 20px; background: #1e293b; color: var(--text-sec); border: 1px solid var(--border);
            display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #64748b; }
        .dot.online { background: var(--success); box-shadow: 0 0 8px rgba(16, 185, 129, 0.4); }
        .dot.syncing { background: var(--warn); animation: blink 0.5s infinite; }
        .dot.error { background: var(--danger); }

        .timer-huge { 
            font-size: 140px; font-weight: 900; font-family: 'Roboto Mono'; 
            /* 关键：防止数字跳动 */
            font-variant-numeric: tabular-nums; 
            color: var(--text-main); line-height: 1; letter-spacing: -6px; margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        
        .control-panel { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .status-text { font-size: 16px; font-weight: 600; color: var(--primary); text-transform: uppercase; letter-spacing: 2px; }
        
        .play-btn {
            width: 80px; height: 80px; border-radius: 50%; border: none; background: var(--primary); color: white;
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.4); cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        .play-btn:hover { transform: scale(1.05); background: var(--primary-active); }
        .play-btn:disabled { background: #334155; cursor: not-allowed; opacity: 0.5; box-shadow: none; }

        .latency-tools {
            margin-top: 40px; background: var(--surface); padding: 15px 25px; border-radius: 12px; border: 1px solid var(--border);
            display: flex; gap: 15px; align-items: center;
        }

        /* MODAL */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center; z-index: 100;
            opacity: 0; pointer-events: none; transition: 0.2s;
        }
        .modal-overlay.open { opacity: 1; pointer-events: auto; }
        .modal-card {
            background: var(--surface); border: 1px solid var(--border); width: 360px; padding: 25px; border-radius: 16px;
            text-align: center;
        }
        .test-circle {
            width: 120px; height: 120px; border-radius: 50%; border: 4px solid var(--border); margin: 20px auto;
            display: flex; align-items: center; justify-content: center; font-weight: 900; font-size: 40px; color: var(--text-sec);
            transition: 0.1s;
        }
        .test-circle.flash { background: var(--primary); border-color: var(--primary); color: white; transform: scale(1.1); }

        @keyframes blink { 50% { opacity: 0.4; } }
    </style>
</head>
<body>

<div id="latency-modal" class="modal-overlay">
    <div class="modal-card">
        <h3 style="margin-top:0">Hardware Latency Test</h3>
        <p style="font-size:13px; color:var(--text-sec); line-height:1.5;">
            1. Tap "Start". You will see a countdown.<br>
            2. <b>Tap the Circle</b> EXACTLY when you hear the "BEEP".<br>
            3. Do this 3 times to average.
        </p>
        <div id="test-visual" class="test-circle" onclick="recordLatencyClick()">--</div>
        <div id="test-result" style="height:20px; font-weight:700; color:var(--primary); margin-bottom:15px;"></div>
        <button class="btn-sm btn-primary" onclick="startLatencyTest()">Start Test Sequence</button>
        <button class="btn-sm btn-outline" onclick="closeLatencyModal()" style="margin-top:10px;">Close</button>
    </div>
</div>

<header>
    <div class="brand">
        <span class="material-icons-round" style="color:var(--primary)">equalizer</span>
        <span>Jack's Sync <span class="version-tag">V4.0 Precision</span></span>
    </div>
    <div class="header-stats">
        <div class="stat-item">OFFSET: <span class="stat-val" id="disp-net-offset">0</span> ms</div>
        <div class="stat-item">LATENCY: <span class="stat-val" id="disp-hw-latency">0</span> ms</div>
        <div class="stat-item">SRC: <span class="stat-val" id="disp-source">LOC</span></div>
    </div>
</header>

<div class="container">
    <aside>
        <div class="playlist-header">
            <div class="input-group">
                <input type="text" id="inp-id" class="dark-input" placeholder="NetEase ID (e.g. 186016)">
                <button class="btn-sm btn-primary" onclick="Playlist.add()">Add</button>
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:10px;">
                <button class="btn-sm btn-outline" onclick="Playlist.importJson()">Import JSON</button>
                <button class="btn-sm btn-outline" onclick="Playlist.clear()" style="color:var(--danger); border-color:rgba(239,68,68,0.3)">Clear</button>
            </div>
        </div>
        <div id="song-list-el" class="song-list"></div>
    </aside>

    <main>
        <div class="sync-status">
            <div id="sync-dot" class="dot"></div>
            <span id="sync-msg">Initializing...</span>
        </div>

        <div id="main-timer" class="timer-huge">--.---</div>
        
        <div class="control-panel">
            <div id="play-status" class="status-text">READY</div>
            <button id="main-play-btn" class="play-btn" onclick="Engine.startSequence()">
                <span class="material-icons-round" style="font-size:36px;">play_arrow</span>
            </button>
        </div>

        <div class="latency-tools">
            <span class="material-icons-round" style="color:var(--text-sec)">tune</span>
            <div style="font-size:12px;">
                <div style="font-weight:700; color:var(--text-main);">Audio Calibration</div>
                <div style="color:var(--text-sec);">Fix bluetooth/speaker delay</div>
            </div>
            <button class="btn-sm btn-outline" style="margin-left:auto" onclick="openLatencyModal()">Calibrate</button>
        </div>
    </main>
</div>

<script>
    /* V4.0 ARCHITECTURE
       1. TimeSync: Manages Taobao/Suning fetching and offset calculation.
       2. AudioCore: Manages AudioContext (Web Audio API) for 0-latency scheduling.
       3. Engine: Manages the Countdown -> Play state machine.
       4. UI: Updates the DOM.
    */

    /* ================= 1. GLOBAL STATE ================= */
    const STATE = {
        songs: JSON.parse(localStorage.getItem('v4_songs')) || [],
        curIdx: 0,
        netOffset: 0,       // Server Time - Local Time
        hwLatency: parseInt(localStorage.getItem('v4_latency')) || 0, // Hardware lag (ms)
        lastSyncTime: 0,
        audioCtx: null,
        isPlaying: false
    };

    /* ================= 2. TIME SYNC ENGINE ================= */
    const TimeSync = {
        async sync() {
            UI.setSyncState('syncing', 'Syncing...');
            
            // 30s Cache Rule
            if (Date.now() - STATE.lastSyncTime < 30000 && STATE.lastSyncTime !== 0) {
                console.log("Sync cached. Skipping.");
                UI.setSyncState('online', 'Synced (Cache)');
                return true;
            }

            try {
                // RACE 1: Taobao API (Highest Precision)
                // Use fetch. If CORS fails, it will throw, catching to fallback.
                const offset = await this.fetchTaobao();
                this.applyOffset(offset, 'Taobao');
                return true;
            } catch (e1) {
                console.warn("Taobao failed:", e1);
                try {
                    // RACE 2: Suning (JSONP fallback)
                    const offset = await this.fetchSuning();
                    this.applyOffset(offset, 'Suning');
                    return true;
                } catch (e2) {
                    console.error("All Sync Failed", e2);
                    UI.setSyncState('error', 'Local Time');
                    STATE.netOffset = 0; // Fallback to local
                    return false; // Soft fail, we allow play but warn
                }
            }
        },

        fetchTaobao() {
            return new Promise(async (resolve, reject) => {
                const t0 = Date.now();
                try {
                    // Note: Taobao might block direct fetch depending on Origin. 
                    // If this fails due to CORS, the catch block handles it.
                    const res = await fetch(`https://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp&_=${t0}`);
                    const data = await res.json();
                    if(!data.data || !data.data.t) throw new Error("Bad Data");
                    
                    const t3 = Date.now();
                    const serverT = parseInt(data.data.t);
                    const rtt = t3 - t0;
                    // Formula: (Server + RTT/2) - LocalEnd
                    const offset = (serverT + rtt/2) - t3;
                    resolve(offset);
                } catch(e) { reject(e); }
            });
        },

        fetchSuning() {
            return new Promise((resolve, reject) => {
                const t0 = Date.now();
                const cb = 'cb_' + Math.random().toString(36).substr(2,9);
                let done = false;
                
                window[cb] = (d) => {
                    done = true;
                    const t3 = Date.now();
                    const offset = (d.currentTime + (t3-t0)/2) - t3;
                    delete window[cb];
                    document.body.removeChild(script);
                    resolve(offset);
                };

                const script = document.createElement('script');
                script.src = `https://f.m.suning.com/api/ct.do?callback=${cb}&_=${t0}`;
                script.onerror = () => { if(!done) reject("Suning Error"); };
                document.body.appendChild(script);
                
                setTimeout(() => { if(!done) reject("Timeout"); }, 2000);
            });
        },

        applyOffset(off, src) {
            STATE.netOffset = off;
            STATE.lastSyncTime = Date.now();
            UI.updateStats();
            UI.setSyncState('online', `Synced: ${src}`);
        },

        now() {
            return Date.now() + STATE.netOffset;
        }
    };

    /* ================= 3. AUDIO CORE (WEB AUDIO API) ================= */
    const AudioCore = {
        init() {
            if (!STATE.audioCtx) {
                STATE.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (STATE.audioCtx.state === 'suspended') {
                STATE.audioCtx.resume();
            }
        },

        async loadBuffer(url) {
            this.init();
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return await STATE.audioCtx.decodeAudioData(arrayBuffer);
        },

        // Play at exact system time (wall clock)
        // targetTime = Wall Clock Timestamp (ms)
        playAt(buffer, targetTimeMs) {
            const ctx = STATE.audioCtx;
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            source.connect(ctx.destination);

            // Calculate precise delay
            // Current Wall Time = Date.now() + netOffset
            // We need to map Wall Time to AudioContext Time
            // AudioContext Time is monotonic from start of context.
            
            const wallNow = TimeSync.now();
            const delayMs = targetTimeMs - wallNow;
            
            // Apply Hardware Latency Compensation (Negative Offset)
            // If hwLatency is 100ms, we want to trigger 100ms EARLIER.
            const hwComp = STATE.hwLatency; 
            
            // Final start time in AudioContext timeline
            // ctx.currentTime + (delay - hwLatency)/1000
            let startAt = ctx.currentTime + ((delayMs - hwComp) / 1000);

            if (startAt < ctx.currentTime) {
                console.warn("Target time passed, playing immediately");
                startAt = ctx.currentTime;
            }

            source.start(startAt);
            
            // Auto-advance logic
            source.onended = () => {
                STATE.isPlaying = false;
                Playlist.next();
            };
            
            return source;
        },

        playTone() {
            // For latency test
            this.init();
            const osc = STATE.audioCtx.createOscillator();
            const gain = STATE.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(STATE.audioCtx.destination);
            
            osc.frequency.value = 1000;
            osc.type = 'square';
            
            const now = STATE.audioCtx.currentTime;
            osc.start(now);
            osc.stop(now + 0.1); // 100ms beep
        }
    };

    /* ================= 4. MAIN ENGINE ================= */
    const Engine = {
        timerId: null,
        targetTime: 0,
        
        async startSequence() {
            if (STATE.songs.length === 0) return alert("Playlist empty!");
            if (STATE.isPlaying) return; // Prevent double click

            const btn = document.getElementById('main-play-btn');
            btn.disabled = true;

            // 1. Force Sync (or check cache)
            await TimeSync.sync();

            // 2. Load Audio (Preload)
            UI.setStatus("BUFFERING...");
            const song = STATE.songs[STATE.curIdx];
            let buffer;
            try {
                // Using NetEase Proxy URL
                const url = `https://music.163.com/song/media/outer/url?id=${song.id}.mp3`;
                buffer = await AudioCore.loadBuffer(url);
            } catch(e) {
                alert("Audio Load Failed");
                btn.disabled = false;
                return;
            }

            // 3. Calculate Target Time
            const now = TimeSync.now();
            // Round up to nearest 10s
            let target = Math.ceil(now / 10000) * 10000;
            
            // < 4s Rule: If too close, add 10s
            if (target - now < 4000) {
                target += 10000;
            }

            this.targetTime = target;
            
            // 4. Schedule Audio
            AudioCore.playAt(buffer, target);
            STATE.isPlaying = true;

            // 5. Start Visual Countdown Loop
            this.loop();
        },

        loop() {
            const now = TimeSync.now();
            const diff = this.targetTime - now;

            if (diff <= 0) {
                // Playing
                document.getElementById('main-timer').innerText = "0.000";
                UI.setStatus("PLAYING");
                document.getElementById('main-play-btn').innerHTML = '<span class="material-icons-round">equalizer</span>';
                // Stop loop, audio handles itself
                return;
            }

            // Update UI
            document.getElementById('main-timer').innerText = (diff / 1000).toFixed(3);
            UI.setStatus(`T - ${(diff/1000).toFixed(0)}s`);
            
            requestAnimationFrame(() => this.loop());
        }
    };

    /* ================= 5. UI & PLAYLIST ================= */
    const UI = {
        setStatus(msg) { document.getElementById('play-status').innerText = msg; },
        setSyncState(cls, msg) {
            const dot = document.getElementById('sync-dot');
            const txt = document.getElementById('sync-msg');
            dot.className = `dot ${cls}`;
            txt.innerText = msg;
        },
        updateStats() {
            document.getElementById('disp-net-offset').innerText = STATE.netOffset.toFixed(0);
            document.getElementById('disp-hw-latency').innerText = STATE.hwLatency;
            document.getElementById('disp-source').innerText = STATE.netOffset === 0 ? "LOC" : "NET";
        }
    };

    const Playlist = {
        add() {
            const id = document.getElementById('inp-id').value;
            if(!id) return;
            STATE.songs.push({ id, name: `Track ${id}` }); // Simplified name for now
            this.save(); this.render();
            document.getElementById('inp-id').value = "";
        },
        importJson() {
            const str = prompt("Paste JSON ([{id, name}...])");
            try {
                const data = JSON.parse(str);
                STATE.songs = [...STATE.songs, ...data];
                this.save(); this.render();
            } catch(e) { alert("Invalid JSON"); }
        },
        clear() { STATE.songs = []; this.save(); this.render(); },
        save() { localStorage.setItem('v4_songs', JSON.stringify(STATE.songs)); },
        render() {
            const el = document.getElementById('song-list-el');
            el.innerHTML = STATE.songs.map((s,i) => `
                <div class="song-item ${i===STATE.curIdx ? 'active' : ''}" onclick="Playlist.select(${i})">
                    <div class="song-info">
                        <h4>${s.name || s.id}</h4>
                        <span>ID: ${s.id}</span>
                    </div>
                    ${i===STATE.curIdx ? '<span class="material-icons-round" style="font-size:16px; color:var(--primary)">play_circle</span>' : ''}
                </div>
            `).join('');
        },
        select(i) {
            if (STATE.isPlaying) return;
            STATE.curIdx = i;
            this.render();
        },
        next() {
            if(STATE.curIdx < STATE.songs.length - 1) {
                STATE.curIdx++;
                this.render();
                // Auto play next logic
                document.getElementById('main-play-btn').disabled = false;
                document.getElementById('main-play-btn').innerHTML = '<span class="material-icons-round" style="font-size:36px;">play_arrow</span>';
                setTimeout(() => Engine.startSequence(), 1000); // Small pause before sync/start
            } else {
                UI.setStatus("FINISHED");
                document.getElementById('main-play-btn').disabled = false;
                document.getElementById('main-play-btn').innerHTML = '<span class="material-icons-round" style="font-size:36px;">replay</span>';
                STATE.curIdx = 0;
            }
        }
    };

    /* ================= 6. LATENCY TESTER ================= */
    let testStage = 0;
    let testTimes = [];
    let testTimer = null;

    function openLatencyModal() { document.getElementById('latency-modal').classList.add('open'); }
    function closeLatencyModal() { document.getElementById('latency-modal').classList.remove('open'); }
    
    function startLatencyTest() {
        testStage = 3;
        testTimes = [];
        runTestStep();
    }

    function runTestStep() {
        const visual = document.getElementById('test-visual');
        const res = document.getElementById('test-result');
        
        if (testStage <= 0) {
            // Finish
            const avg = Math.floor(testTimes.reduce((a,b)=>a+b,0) / testTimes.length);
            STATE.hwLatency = avg;
            localStorage.setItem('v4_latency', avg);
            UI.updateStats();
            res.innerText = `DONE! Latency set to ${avg}ms`;
            visual.innerText = "OK";
            return;
        }

        res.innerText = `Remaining: ${testStage}`;
        visual.innerText = "3...";
        visual.className = "test-circle";

        let count = 3;
        const countdown = setInterval(() => {
            count--;
            if(count > 0) {
                visual.innerText = count + "...";
            } else {
                clearInterval(countdown);
                visual.innerText = "TAP!";
                visual.className = "test-circle flash";
                AudioCore.playTone();
                testTimer = Date.now();
            }
        }, 1000);
    }

    function recordLatencyClick() {
        if (!testTimer) return;
        const diff = Date.now() - testTimer;
        testTimes.push(diff);
        testTimer = null;
        document.getElementById('test-result').innerText = `Detected: ${diff}ms`;
        testStage--;
        setTimeout(runTestStep, 1000);
    }

    /* ================= INIT ================= */
    Playlist.render();
    UI.updateStats();
    // Pre-warm Audio Context on first interaction
    window.addEventListener('click', () => AudioCore.init(), {once:true});

</script>
</body>
</html>
